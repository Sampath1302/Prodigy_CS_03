import math
import re
import getpass


RE_UPPER = re.compile(r"[A-Z]")
RE_LOWER = re.compile(r"[a-z]")
RE_DIGIT = re.compile(r"\d")
RE_SPECIAL = re.compile(r"[^A-Za-z0-9]")
RE_REPEAT = re.compile(r"(.)\1{2,}")
RE_SEQ = re.compile(r"(?:012|123|234|345|456|567|678|789|abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|mno|nop|opq|pqr|qrs|rst|stu|tuv|uvw|vwx|wxy|xyz)", re.IGNORECASE)

def shannon_entropy(password: str) -> float:
    """Estimate Shannon entropy in bits for the given password string."""
    if not password:
        return 0.0
    freq = {}
    for ch in password:
        freq[ch] = freq.get(ch, 0) + 1
    H = 0.0
    L = len(password)
    for count in freq.values():
        p = count / L
        H -= p * math.log2(p)
    return H * L

def charset_size(password: str) -> int:
    """Estimate charset size used by password (rough heuristic)."""
    size = 0
    if RE_LOWER.search(password):
        size += 26
    if RE_UPPER.search(password):
        size += 26
    if RE_DIGIT.search(password):
        size += 10
    if RE_SPECIAL.search(password):
        size += 32
    return size

def estimate_entropy_via_charset(password: str) -> float:
    """Alternative entropy estimate using charset size: log2(charset_size^len)"""
    cs = charset_size(password)
    if cs <= 1:
        return 0.0
    return math.log2(cs) * len(password)
def assess_password(password: str) -> dict:

    p = password or ""
    L = len(p)

    has_upper = bool(RE_UPPER.search(p))
    has_lower = bool(RE_LOWER.search(p))
    has_digit = bool(RE_DIGIT.search(p))
    has_special = bool(RE_SPECIAL.search(p))

    entropy_sh = shannon_entropy(p)
    entropy_cs = estimate_entropy_via_charset(p)


    score = 0.0
    if L == 0:
        length_score = 0
    elif L < 8:
        length_score = (L / 8) * 15
    elif L < 12:
        length_score = 15 + ((L - 7) / 4) * 10
    else:
        length_score = 30 + min((L - 12) * 1.5, 10)
    score += length_score


    variety = sum([has_lower, has_upper, has_digit, has_special])
    variety_score = (variety / 4) * 30
    score += variety_score

    entropy_bonus = min(max((entropy_cs / 80) * 20, 0), 20)
    score += entropy_bonus

    penalties = 0.0
    suggestions = []

    if RE_REPEAT.search(p):
        penalties += 15
        suggestions.append("Avoid repeated characters (e.g., 'aaa' or '111').")

    if RE_SEQ.search(p):
        penalties += 10
        suggestions.append("Avoid simple sequences (e.g., '123', 'abc').")
    common = {"password", "123456", "qwerty", "letmein", "admin", "welcome", "passw0rd", "12345678"}
    if p.lower() in common or p in common:
        penalties += 40
        suggestions.append("Password is a commonly used password — choose something unique.")

    if not (has_lower or has_upper) and (has_digit or has_special):

        penalties += 5
        suggestions.append("Include both letters and numbers/special characters.")
    if (has_lower and not has_upper) and not has_digit and not has_special and L < 12:
        penalties += 5
        suggestions.append("Add uppercase letters, numbers, or symbols to increase strength.")

    score -= penalties


    score = max(0.0, min(100.0, score))

    if score < 20:
        verdict = "Very weak"
    elif score < 40:
        verdict = "Weak"
    elif score < 60:
        verdict = "Fair"
    elif score < 75:
        verdict = "Good"
    elif score < 90:
        verdict = "Strong"
    else:
        verdict = "Excellent"

    if verdict != "Excellent":
        if L < 12:
            suggestions.append("Use a longer password (12+ characters recommended).")
        if not has_upper:
            suggestions.append("Add uppercase letters (A-Z).")
        if not has_lower:
            suggestions.append("Add lowercase letters (a-z).")
        if not has_digit:
            suggestions.append("Include digits (0-9).")
        if not has_special:
            suggestions.append("Include special characters (e.g., !@#$%^&*()).")
        suggestions.append("Consider a passphrase (multiple unrelated words) or a password manager.")
    else:
        suggestions.append("Looks good — consider using a password manager to generate/store it safely.")

    seen = set()
    uniq_suggestions = []
    for s in suggestions:
        if s not in seen:
            uniq_suggestions.append(s)
            seen.add(s)

    return {
        "password_masked": ("*" * (len(p) - 4) + p[-4:]) if len(p) >= 4 else ("*" * len(p)),
        "length": L,
        "has_upper": has_upper,
        "has_lower": has_lower,
        "has_digit": has_digit,
        "has_special": has_special,
        "entropy_shannon_bits": round(entropy_sh, 2),
        "entropy_charset_bits": round(entropy_cs, 2),
        "score": round(score, 1),
        "verdict": verdict,
        "suggestions": uniq_suggestions,
        "penalties_applied": round(penalties, 1),
    }

def pretty_print_assessment(a: dict):
    print("\nPassword Assessment")
    print("-------------------")
    print(f"Password (masked): {a['password_masked']}")
    print(f"Length: {a['length']}")
    print("Contains:", end=" ")
    parts = []
    if a['has_lower']: parts.append("lowercase")
    if a['has_upper']: parts.append("uppercase")
    if a['has_digit']: parts.append("digits")
    if a['has_special']: parts.append("specials")
    print(", ".join(parts) if parts else "none")
    print(f"Estimated entropy (Shannon): {a['entropy_shannon_bits']} bits")
    print(f"Estimated entropy (charset): {a['entropy_charset_bits']} bits")
    print(f"Score: {a['score']} / 100  -> {a['verdict']}")
    if a['penalties_applied'] > 0:
        print(f"Penalties applied: {a['penalties_applied']} (common patterns, repeats, etc.)")
    print("\nSuggestions:")
    for s in a['suggestions']:
        print(" -", s)
    print()

def main():
    print("Password Complexity Checker")
    print("(Input is hidden; press Enter to submit)\n")
    try:
        pwd = getpass.getpass("Enter password to evaluate: ")
    except Exception:
        pwd = input("Enter password to evaluate: ")
    assessment = assess_password(pwd)
    pretty_print_assessment(assessment)

if __name__ == "__main__":
    main()
